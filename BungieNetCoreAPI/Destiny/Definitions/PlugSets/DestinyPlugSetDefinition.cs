using NetBungieAPI.Attributes;
using Newtonsoft.Json;
using System.Collections.ObjectModel;

namespace NetBungieAPI.Destiny.Definitions.PlugSets
{
    /// <summary>
    /// Sometimes, we have large sets of reusable plugs that are defined identically and thus can (and in some cases, are so large that they *must*) be shared across the places where they are used. These are the definitions for those reusable sets of plugs.
    /// </summary>
    [DestinyDefinition(DefinitionsEnum.DestinyPlugSetDefinition, DefinitionSources.All, DefinitionKeyType.UInt)]
    public class DestinyPlugSetDefinition : IDestinyDefinition, IDeepEquatable<DestinyPlugSetDefinition>
    {
        public DestinyDefinitionDisplayProperties DisplayProperties { get; }
        /// <summary>
        /// Mostly for our debugging or reporting bugs, BNet is making "fake" plug sets in a desperate effort to reduce socket sizes.
        /// <para/>
        /// If this is true, the plug set was generated by BNet: if it looks wrong, that's a good indicator that it's bungie.net that fucked this up.
        /// </summary>
        public bool IsFakePlugSet { get; }
        /// <summary>
        /// This is a list of pre-determined plugs that can be plugged into this socket, without the character having the plug in their inventory.
        /// <para/>
        /// If this list is populated, you will not be allowed to plug an arbitrary item in the socket: you will only be able to choose from one of these reusable plugs.
        /// </summary>
        public ReadOnlyCollection<PlugSetReusablePlugItem> ReusablePlugItems { get; }
        public bool Blacklisted { get; }
        public uint Hash { get; }
        public int Index { get; }
        public bool Redacted { get; }

        [JsonConstructor]
        internal DestinyPlugSetDefinition(DestinyDefinitionDisplayProperties displayProperties, bool isFakePlugSet, PlugSetReusablePlugItem[] reusablePlugItems,
            bool blacklisted, uint hash, int index, bool redacted)
        {
            DisplayProperties = displayProperties;
            IsFakePlugSet = isFakePlugSet;
            ReusablePlugItems = reusablePlugItems.AsReadOnlyOrEmpty();
            Blacklisted = blacklisted;
            Hash = hash;
            Index = index;
            Redacted = redacted;
        }

        public override string ToString()
        {
            return $"{Hash} {DisplayProperties.Name}: {DisplayProperties?.Description}";
        }

        public bool DeepEquals(DestinyPlugSetDefinition other)
        {
            return other != null &&
                   (DisplayProperties != null ? DisplayProperties.DeepEquals(other.DisplayProperties) : other.DisplayProperties == null) &&
                   IsFakePlugSet == other.IsFakePlugSet &&
                   ReusablePlugItems.DeepEqualsReadOnlyCollections(other.ReusablePlugItems) &&
                   Blacklisted == other.Blacklisted &&
                   Hash == other.Hash &&
                   Index == other.Index &&
                   Redacted == other.Redacted;
        }
        public void MapValues()
        {
            foreach (var item in ReusablePlugItems)
            {
                item.PlugItem.TryMapValue();
            }
        }
    }
}
